%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                       %%%
%%%             Trajectories Constitution                 %%%
%%%                                                       %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Originally created, unchanged from Cori Pegliasco's code
% This function is made for daily data.
%
% The function built the trajectory by assembling the consecutive eddies,
% based on contour intersections, following Pegliasco et al (2015)
% A cost function is applied when more than 1 contour intersect.
% Inputs:
% - files_location : Path of the directory containing EXTRACTION and FUNCTIONS
% - dist_lim : Maximum distance (in degree) of the closest centroid
% - intersect_cover = Percentage of the minimum superposition area needed
% to define a splitting event
% - nDT : Maximum number of time steps allowed when searching for the next eddy
% Outputs:
% - several CE_Trajectories_xx.mat and AE_trajectories_xx.mat containing :
%   the trajectories structures AEs_traj(numtraj) and CEs_traj(numtraj)
%   a vector lifetime (length(lifetime) = numtraj_tot)
%   the matrices idtraj and split_id
%   the value numtraj (number of trajectories saved in the .mat)
%
% The function allows the description of 2 particular events:
% - a merging event : when a trajectory match with an eddy forming already part of an older trajectory.
% In this case, the merged trajectory is stopped, reccording the ID of the
% older trajectory and the time of the event.
% Merging_time = Time_index & Merged_with = ID of the older trajectory
% - a splitting event : when a large eddy splits in 2 or more eddies on the next timestep.
% The eddies are generated by splitting when the superposition area between the
% splitted eddy and the new ones is over a percentage defined by intersect_cover.
% Splitting_time = time index of the splitting
% Splitting_in = ID of the eddies generated
% split_id(generated Eddy_index,Time_index) = ID trajectory
% The eddies generated by a splitting event are considered as a new
% trajectory, the information is now in Splitting_from_traj = ID of the
% splitted trajectory
% Warning: a trajectory can split several times
%
% The function allows the research of an intersecting eddy several time
% steps after the considered map.
% When an eddy is found at map+1dt, it is added to the trajectory, Eddy_found_at = 1,
% and the characteristics of the matching eddy are added to the trajectory.
% If ther is no eddy intersects at map+1dt, the function searches at map+2dt, etc,
% until the maximum time steps nDT is reached.
% If an eddy intersects at map+xdt, it is added to the trajectory, Eddy_found_at = x.
% To fill the intermediate timesteps, a linear interpolation of the parameters is done.
% NaNs are added for Xcontour, Ycontour, Eddy_index, Eddy_found_at and ID_eddies for the
% missing steps.
%
% The functions called in this script can be found in the file FUNCTIONS
%
% Juin 2016, Cori Pegliasco
%

%% load parameters
function Paul_OPT_Step5_SS(inputDir,propDir,trajDir,depthlevel)

load('DefaultData_OPT.mat') %See Paul_FSS_CreateDefaultSettings.m
Paul_OPT_LoadDefaultSettings(); %See corresponding function
warning off
Extraction_Type = 'Normal Extraction';
addpath(strcat(basepath, 'FUNCTIONS'));

n_traj = 5000;
dist_lim = 2; %3
intersect_cover = 25; %25
nDT = 3;

% input_dir_interim = strcat(basepath, '/EXTRACTION/INDIVIDUAL_FILES/NEM_DLEV_');
% input_dir_config = strcat(input_dir_interim, num2str(depthlevel));
input_dir_config = inputDir;
load(strcat(input_dir_config, '/ConfigFile_fulltime.mat')); %ConfigFile2_fulltime.mat');

input_dir= propDir;
input_dir= strcat(input_dir, num2str(depthlevel));

output_dir= trajDir;
output_dir= strcat(output_dir, num2str(depthlevel));

[status,message,messageid] = mkdir(output_dir);

% Open contours matrices
filename_cont = [input_dir '/Eddy_Contours.mat'];
load(filename_cont,'AEs')

% Open Properties matrices
filename = [input_dir '/AE_Properties.mat'];
load(filename)

%% Reorganize properties by decreasing amplitude
% Reorganize eddy properties by decreasing amplitude and store
% the resulting indices in the variable
% (Stronger Amplitude of Amplitudd(IND)= First line of non-NAN data )
[~,IND] = sort(Amplitude,1,'descend');
listvar = whos; % Create a structure list of variables name
[nr,nc] = size(Amplitude); % Store dimensions of a "full" variable

% Loop to reorganize each variable following the decreasing amplitude order
% specified by IND.
for k = 1:nc
    for i=1:length(listvar)
        N = listvar(i).size;
        if N(1)==nr && N(2)==nc  && strcmp(listvar(i).name,'IND')~=1 % To reorganize variable of nr,nc size but not IND
            eval(['' listvar(i).name '(:,k,:)=' listvar(i).name '(IND(:,k),k,:);']);
        end
    end
end

%% Initialization
NN = isfinite(Xcenter);         % Matrix = 1 when there is an eddy
numtraj = 0;                    % Traj position counter
numtraj_tot = 0;                % Trajectories counter
idtraj = NaN(nr,nc);            % Matrix with the associated trajectory id of every eddy evolved in a trajectory
split_id = NaN(nr,nc);          % Matrix recording if the eddy is due to a splitting event
nbre_split = NaN([1 1000]);
% Count to save the trajectory matrices (every n_traj trajectories)
aa = 0;
n_traj = 5000;
id_anti = 1:nr*nc;
ID_anti = reshape(id_anti,nr,nc); % matrix of unique ID for AEs

% Create Structure for Anticyclonic trajectories
AEs_traj = struct('ID_traj',{},'Lifetime',{},'Xcenter',{},'Ycenter',{},'Xcentroid',{},'Ycentroid',{},'Xcontour',{},'Ycontour',{},...
    'Amplitude',{},'Radius',{},...
    'Area',{},'Speed',{},'Vorticity',{},'OW',{},'EKE',{},...
    'Date',{},'Time_index',{},'Eddy_index',{},'ID_eddies',{},...
    'Merging_time',{},'Merged_with_traj',{},'Splitting_time',{},'Splitted_in',{},'Splitting_from_traj',{},'Eddy_found_at',{});
AEs_traj(n_traj).Lifetime = 1;
% Fields of the structure:
% ID_traj: each trajectory has a proper number              (value)
% Lifetime: total duration of the trajectory                (value)
% For each map, we keep:
% Xcenter, Ycenter: position of the eddy center             (vectors)
% Xcentroid, Ycentroid: position of the eddy centroid       (vectors)
% Xcontour, Ycontour: vectors of the eddy contour           (cell)
% Amplitude: difference center-contour [cm]                 (vector)
% Radius: Equivalent radius [km]                            (vector)
% Area: Area [km^2]                                         (vector)
% Speed: mean speed [m/s]                                   (vector)
% Vorticity : mean vorticity [1/s]                          (vector)
% OW: mean Okubo-Weiss parameter [1/s]                      (vector)
% EKE: mean Eddy Kinetic Energy [(m/s)^2]                   (vector)
% Date: date of the map (matlab format)                     (vector)
% Time_index: matrix column indice                          (vector)
% Eddy_index: matrix line indice                            (vector)
% ID_eddies: unique ID of the eddies involved in the trajectory (vector)
% Merging_time: time index of the merging event             (value)
% Merged_with_traj: proper ID of the main trajectory joined (value)
% Splitting_time: time index of the splitting event(s)      (short vector)
% Splitted_in: ID of the eddies generated by the splitting event (short vector)
% Splitting_from_traj: ID of the trajectory producing the splitting (value)
% Eddy_found_at: possibility of searching an eddy at map+dt, map+2dt etc. (vector)

date_num = double(date_num);

%% Making trajectories

for j=1:nc-1 % for all timesteps
    disp([ 'AE Map: ' datestr(date_num(j)) ])              % Map in process
    idx = find(NN(:,j)==1 & isnan(idtraj(IND(:,j),j))==1)';    % Eddies non already associated to a trajectory

    for i=idx % Loop on each eddy (from the biggest to the smallest)
        if  numtraj == n_traj       % Save matrix every n_traj trajectories
            aa = aa+1;
            if aa<10; aa_2=['0',num2str(aa)]; else aa_2=num2str(aa); end
            save([output_dir, '/AE_Trajectories', aa_2, '.mat'],'Metadata','AEs_traj','idtraj','split_id','numtraj','lifetime') %Create new matrix
            disp(['AEs ' aa_2 ' successfully saved'])
            clear AEs_traj %Erase previous computed trajectories
            AEs_traj = struct('ID_traj',{},'Lifetime',{},'Xcenter',{},'Ycenter',{},'Xcentroid',{},'Ycentroid',{},'Xcontour',{},'Ycontour',{},...
                'Amplitude',{},'Radius',{},'Area',{},'Speed',{},'Vorticity',{},'OW',{},'EKE',{},...
                'Date',{},'Time_index',{},'Eddy_index',{},'ID_eddies',{},...
                'Merging_time',{},'Merged_with_traj',{},'Splitting_time',{},'Splitted_in',{},'Splitting_from_traj',{},'Eddy_found_at',{});
            AEs_traj(n_traj).Lifetime = 1;
            lifetime = NaN([1 n_traj]);
            numtraj=0;
        end

        numtraj_tot = numtraj_tot+1; 	% Each new eddy become a trajectory (total count)
        numtraj = numtraj + 1;  	% Each new eddy become a trajectory (current count)
        indy = j; 			% time position (column)
        indx = i; 			% eddy studied position (row)

        if isnan(split_id(IND(i,j),j))==0 % If this eddy is the result of a splitting
            AEs_traj(numtraj).Splitting_from_traj = split_id(IND(i,j),j);
        end

        %%% Fill the trajectory parameters whith the first eddy characteristics
        AEs_traj(numtraj).ID_traj = numtraj_tot;
        AEs_traj(numtraj).Xcenter(end+1) = Xcenter(i,j);
        AEs_traj(numtraj).Ycenter(end+1) = Ycenter(i,j);
        AEs_traj(numtraj).Xcentroid(end+1) = Xcentroid(i,j);
        AEs_traj(numtraj).Ycentroid(end+1) = Ycentroid(i,j);
        AEs_traj(numtraj).Xcontour{1} = AEs{i,j,1};
        AEs_traj(numtraj).Ycontour{1} = AEs{i,j,2};
        AEs_traj(numtraj).Radius(end+1) = Radius(i,j);
        AEs_traj(numtraj).Area(end+1) = Area(i,j);
        AEs_traj(numtraj).Amplitude(end+1) = Amplitude(i,j)*100;
        AEs_traj(numtraj).EKE(end+1) = EKE(i,j);
        if strcmp(Extraction_Type,'Full Extraction') == 1
            AEs_traj(numtraj).Speed(end+1) = Speed(i,j);
            AEs_traj(numtraj).Vorticity(end+1) = Vorticity(i,j);
            AEs_traj(numtraj).OW(end+1) = OW(i,j);
        end
        AEs_traj(numtraj).Eddy_index(end+1) = IND(i,j); % Index position (before sorting)
        AEs_traj(numtraj).Date(end+1) = date_num(j);
        AEs_traj(numtraj).Time_index(end+1) = j;        % Column time index
        AEs_traj(numtraj).Lifetime = 1;                 % Lifetime of the eddy
        AEs_traj(numtraj).ID_eddies(end+1) = ID_anti(IND(i,j),j); % Store ID of Eddies
        AEs_traj(numtraj).Eddy_found_at = 0;

        idtraj(IND(i,j),j) = numtraj_tot;

        eddy = 1;

        while eddy==1  % While an eddy is detected and it is not the last day of the data time coverage

            for DT=1:nDT % possibility of searching until nDT timesteps
                eddy_next = [];

                % search for the closest eddies on the next map
                [next_map_eddies,tot_dist,found_centroid_at] = cori_find_eddy_next_map(Xcentroid,Ycentroid,indx,indy,DT,dist_lim,nc);

                if isempty(next_map_eddies)==0 % if a close eddy is found
                    % testing the contours intersections
                    [matching_contour,area_intersection] = cori_matching_contours(AEs,Area,indx,indy,DT,next_map_eddies,tot_dist);
                    %area_intersection

                    if isempty(matching_contour)==0 && length(matching_contour)==1 % only one contour
                        eddy_next = matching_contour;

                    elseif isempty(matching_contour)==0 && length(matching_contour) >1 % more than 1 contour -> cost function
                        % several areas -> intersect_cover to see if it is
                        % a splitting event
                        sev_areas = find(area_intersection >= intersect_cover);
                        if length(sev_areas)>1 % splitting event -> reccord the eddies generated
                            if isempty(AEs_traj(numtraj).Splitting_time)==1
                                AEs_traj(numtraj).Splitting_time(1) = indy+DT;
                                AEs_traj(numtraj).Splitted_in{1} = IND(matching_contour(sev_areas),indy+DT);
                                time_split = 1;
                            else
                                time_split = time_split + 1;
                                AEs_traj(numtraj).Splitting_time(end+1) = indy+DT;
                                AEs_traj(numtraj).Splitted_in{time_split} = IND(matching_contour(sev_areas),indy+DT);
                            end
                            split_id(IND(matching_contour(sev_areas),indy+DT),indy+DT) = numtraj_tot;
                        end

                        % Splitting or not, apply the cost function if more
                        % than 1 contour
                        [min_CF] = cori_cost_function(matching_contour,indy,indx,Radius,Amplitude,EKE,Xcenter,Ycenter,...
                            mean_delt_Rad,mean_delt_Ampl,mean_delt_EKE,mean_delt_dist,std_delt_Rad,std_delt_Ampl,std_delt_EKE,std_delt_dist,DT);
                        eddy_next = matching_contour(min_CF);
                    end
                end

                if isempty(eddy_next) == 0 % an eddy is found

                    % fill the trajectory
                    for dt=1:DT
                        AEs_traj(numtraj).Xcenter(end+1) = ((DT-dt)*Xcenter(indx,indy) + Xcenter(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).Ycenter(end+1) = ((DT-dt)*Ycenter(indx,indy) + Ycenter(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).Xcentroid(end+1) = ((DT-dt)*Xcentroid(indx,indy) + Xcentroid(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).Ycentroid(end+1) = ((DT-dt)*Ycentroid(indx,indy) + Ycentroid(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).Radius(end+1) = ((DT-dt)*Radius(indx,indy) + Radius(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).Area(end+1) = ((DT-dt)*Area(indx,indy) + Area(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).Amplitude(end+1) = 100*((DT-dt)*Amplitude(indx,indy) + Amplitude(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).EKE(end+1) = ((DT-dt)*EKE(indx,indy) + EKE(eddy_next,indy+DT)*dt)/DT;
                        AEs_traj(numtraj).Date(end+1) = date_num(indy+dt);
                        AEs_traj(numtraj).Time_index(end+1) = indy+dt;
                        AEs_traj(numtraj).Lifetime = AEs_traj(numtraj).Lifetime+1;
                        if strcmp(Extraction_Type,'Full Extraction') ==1
                            AEs_traj(numtraj).Speed(end+1) = ((DT-dt)*Speed(indx,indy) + Speed(eddy_next,indy+DT)*dt)/DT;
                            AEs_traj(numtraj).Vorticity(end+1) = ((DT-dt)*Vorticity(indx,indy) + Vorticity(eddy_next,indy+DT)*dt)/DT;
                            AEs_traj(numtraj).OW(end+1) = ((DT-dt)*OW(indx,indy) + OW(eddy_next,indy+DT)*dt)/DT;
                        end
                        if dt==DT
                            AEs_traj(numtraj).Xcontour{end+1} = AEs{eddy_next,indy+DT,1};
                            AEs_traj(numtraj).Ycontour{end+1} = AEs{eddy_next,indy+DT,2};
                            AEs_traj(numtraj).Eddy_index(end+1) = IND(eddy_next,indy+DT);
                            AEs_traj(numtraj).ID_eddies(end+1) = ID_anti(IND(eddy_next,indy+DT),indy+DT);
                            AEs_traj(numtraj).Eddy_found_at(end+1) = DT;
                        else
                            AEs_traj(numtraj).Xcontour{end+1} = NaN;
                            AEs_traj(numtraj).Ycontour{end+1} = NaN;
                            AEs_traj(numtraj).Eddy_index(end+1) = NaN;
                            AEs_traj(numtraj).ID_eddies(end+1) = NaN;
                            AEs_traj(numtraj).Eddy_found_at(end+1) = NaN;
                        end

                    end
                    if isnan(idtraj(IND(eddy_next,indy+DT),indy+DT)) == 0 % the matching eddy is already part of a trajectory -> merging event
                        AEs_traj(numtraj).Merged_with_traj(end+1) = idtraj(IND(eddy_next,indy+DT),indy+DT);
                        AEs_traj(numtraj).Merging_time(end+1) = indy+DT;
                        lifetime(numtraj) = AEs_traj(numtraj).Lifetime;
                        eddy = 0;
                        % -> the trajectory is stopped
                        break
                    end

                    idtraj(IND(eddy_next,indy+DT),indy+DT) = numtraj_tot;
                    % go to next map, looking for the next eddy
                    indy = indy+DT;
                    indx = eddy_next;
                    break
                end
            end

            if DT==nDT && isempty(eddy_next) ==1 	% at the end of the trajectory
                %  nbre_split(numtraj_tot) = time_split;   % to count the number of splitting / trajectory
                lifetime(numtraj) = AEs_traj(numtraj).Lifetime; % reccording the lifetime
                eddy = 0;
                break
            end
        end
    end
end

% Last saving
aa = aa+1;
if aa<10; aa_2=['0',num2str(aa)]; else aa_2=num2str(aa); end
save([output_dir, '/AE_Trajectories', aa_2, '.mat'],'Metadata','AEs_traj','idtraj','split_id','numtraj','lifetime','ID_anti') %Create new matrix
disp(['AEs ' aa_2 ' successfully saved'])

%% CEs

%% load parameters
keep input_dir output_dir n_traj dist_lim intersect_cover Extraction_Type nDT
warning off

% Open contours matrices
filename_cont = [input_dir '/Eddy_Contours.mat'];
load(filename_cont,'CEs')
warning off

% Open Anticyclonic matrix
filename = [input_dir '/CE_Properties.mat'];
load(filename)

%% Reorganize properties by decreasing amplitude
% Reorganize eddy properties by decreasing amplitude and store
% the resulting indices in the variable
% (Stronger Amplitude of Amplitudd(IND)= First line of non-NAN data )
[~,IND] = sort(Amplitude,1,'descend');
listvar = whos; % Create a structure list of variables name
[nr,nc] = size(Amplitude); % Store dimensions of a "full" variable

% Loop to reorganize each variable following the decreasing amplitude order
% specified by IND.
for k = 1:nc
    for i=1:length(listvar)
        N = listvar(i).size;
        if N(1)==nr && N(2)==nc  && strcmp(listvar(i).name,'IND')~=1 % To reorganize variable of nr,nc size but not IND
            eval(['' listvar(i).name '(:,k,:)=' listvar(i).name '(IND(:,k),k,:);']);
        end
    end
end

%% Initialization
NN = isfinite(Xcenter);         % Matrix = 1 when there is an eddy
numtraj = 0;                    % Traj position counter
numtraj_tot = 0;                % Trajectories counter
idtraj = NaN(nr,nc);            % Matrix with the associated trajectory id of every eddy evolved in a trajectory
split_id = NaN(nr,nc);          % Matrix recording if the eddy is due to a splitting event
nbre_split = NaN([1 1000]);
% Count to save the trajectory matrices (every n_traj trajectories)
aa = 0;
n_traj = 5000;
id_cyclo = 1:nr*nc;
ID_cyclo = reshape(id_cyclo,nr,nc); % matrix of unique ID for CEs

%h = waitbar(0,'Part I.Cyclones');

% Create Structure for Cyclonic trajectories
CEs_traj = struct('ID_traj',{},'Lifetime',{},'Xcenter',{},'Ycenter',{},'Xcentroid',{},'Ycentroid',{},'Xcontour',{},'Ycontour',{},...
    'Amplitude',{},'Radius',{},...
    'Area',{},'Speed',{},'Vorticity',{},'OW',{},'EKE',{},...
    'Date',{},'Time_index',{},'Eddy_index',{},'ID_eddies',{},...
    'Merging_time',{},'Merged_with_traj',{},'Splitting_time',{},'Splitted_in',{},'Splitting_from_traj',{},'Eddy_found_at',{});
CEs_traj(n_traj).Lifetime = 1;
% Fields of the structure:
% ID_traj: each trajectory has a proper number              (value)
% Lifetime: total duration of the trajectory                (value)
% For each map, we keep:
% Xcenter, Ycenter: position of the eddy center             (vectors)
% Xcentroid, Ycentroid: position of the eddy centroid       (vectors)
% Xcontour, Ycontour: vectors of the eddy contour           (cell)
% Amplitude: difference center-contour [cm]                 (vector)
% Radius: Equivalent radius [km]                            (vector)
% Area: Area [km^2]                                         (vector)
% Speed: mean speed [m/s]                                   (vector)
% Vorticity : mean vorticity [1/s]                          (vector)
% OW: mean Okubo-Weiss parameter [1/s]                      (vector)
% EKE: mean Eddy Kinetic Energy [(m/s)^2]                   (vector)
% Date: date of the map (matlab format)                     (vector)
% Time_index: matrix column indice                          (vector)
% Eddy_index: matrix line indice                            (vector)
% ID_eddies: unique ID of the eddies involved in the trajectory (vector)
% Merging_time: time index of the merging event             (value)
% Merged_with_traj: proper ID of the main trajectory joined (value)
% Splitting_time: time index of the splitting event(s)      (short vector)
% Splitted_in: ID of the eddies generated by the splitting event (short vector)
% Splitting_from_traj: ID of the trajectory producing the splitting (value)
% Eddy_found_at: possibility of searching an eddy at map+dt, map+2dt etc. (vector)

date_num = double(date_num);

%% Making trajectories

for j=1:nc-1 % for all timesteps
    % waitbar(j/(nc-1),h)

    disp([ 'CE Map: ' datestr(date_num(j)) ])              % Map in process
    idx = find(NN(:,j)==1 & isnan(idtraj(IND(:,j),j))==1)';    % Eddies non already associated to a trajectory

    for i=idx % Loop on each eddy (from the biggest to the smallest)
        if  numtraj == n_traj       % Save matrix every n_traj trajectories
            aa = aa+1;
            if aa<10; aa_2=['0',num2str(aa)]; else aa_2=num2str(aa); end
            save([output_dir, '/CE_Trajectories', aa_2, '.mat'],'Metadata','CEs_traj','idtraj','split_id','numtraj','lifetime') %Create new matrix
            disp(['CEs ' aa_2 ' successfully saved'])
            clear CEs_traj %Erase previous computed trajectories
            CEs_traj = struct('ID_traj',{},'Lifetime',{},'Xcenter',{},'Ycenter',{},'Xcentroid',{},'Ycentroid',{},'Xcontour',{},'Ycontour',{},...
                'Amplitude',{},'Radius',{},'Area',{},'Speed',{},'Vorticity',{},'OW',{},'EKE',{},...
                'Date',{},'Time_index',{},'Eddy_index',{},'ID_eddies',{},...
                'Merging_time',{},'Merged_with_traj',{},'Splitting_time',{},'Splitted_in',{},'Splitting_from_traj',{},'Eddy_found_at',{});
            CEs_traj(n_traj).Lifetime = 1;
            lifetime = NaN([1 n_traj]);
            numtraj=0;
        end

        numtraj_tot = numtraj_tot+1; 	% Each new eddy become a trajectory (total count)
        numtraj = numtraj + 1;  	% Each new eddy become a trajectory (current count)
        indy = j; 			% time position (column)
        indx = i; 			% eddy studied position (row)

        if isnan(split_id(IND(i,j),j))==0 % If this eddy is the result of a splitting
            CEs_traj(numtraj).Splitting_from_traj = split_id(IND(i,j),j);
        end

        %% Fill the trajectory parameters whith the first eddy characteristics
        CEs_traj(numtraj).ID_traj = numtraj_tot;
        CEs_traj(numtraj).Xcenter(end+1) = Xcenter(i,j);
        CEs_traj(numtraj).Ycenter(end+1) = Ycenter(i,j);
        CEs_traj(numtraj).Xcentroid(end+1) = Xcentroid(i,j);
        CEs_traj(numtraj).Ycentroid(end+1) = Ycentroid(i,j);
        CEs_traj(numtraj).Xcontour{1} = CEs{i,j,1};
        CEs_traj(numtraj).Ycontour{1} = CEs{i,j,2};
        CEs_traj(numtraj).Radius(end+1) = Radius(i,j);
        CEs_traj(numtraj).Area(end+1) = Area(i,j);
        CEs_traj(numtraj).Amplitude(end+1) = Amplitude(i,j)*100;
        CEs_traj(numtraj).EKE(end+1) = EKE(i,j);
        if strcmp(Extraction_Type,'Full Extraction') == 1
            CEs_traj(numtraj).Speed(end+1) = Speed(i,j);
            CEs_traj(numtraj).Vorticity(end+1) = Vorticity(i,j);
            CEs_traj(numtraj).OW(end+1) = OW(i,j);
        end
        CEs_traj(numtraj).Eddy_index(end+1) = IND(i,j); % Index position (before sorting)
        CEs_traj(numtraj).Date(end+1) = date_num(j);
        CEs_traj(numtraj).Time_index(end+1) = j;        % Column time index
        CEs_traj(numtraj).Lifetime = 1;                 % Lifetime of the eddy
        CEs_traj(numtraj).ID_eddies(end+1) = ID_cyclo(IND(i,j),j); % Store ID of Eddies
        CEs_traj(numtraj).Eddy_found_at = 0;

        idtraj(IND(i,j),j) = numtraj_tot;

        eddy = 1;

        while eddy==1  % While an eddy is detected and it is not the last day of the data time coverage

            for DT=1:nDT % possibility of searching until nDT timesteps
                eddy_next = [];

                % search for the closest eddies on the next map
                [next_map_eddies,tot_dist,found_centroid_at] = cori_find_eddy_next_map(Xcentroid,Ycentroid,indx,indy,DT,dist_lim,nc);

                if isempty(next_map_eddies)==0 % if a close eddy is found
                    % testing the contours intersections
                    [matching_contour,area_intersection] = cori_matching_contours(CEs,Area,indx,indy,DT,next_map_eddies,tot_dist);


                    if isempty(matching_contour)==0 && length(matching_contour)==1 % only one contour
                        eddy_next = matching_contour;

                    elseif isempty(matching_contour)==0 && length(matching_contour) >1 % more than 1 contour -> cost function
                        % several areas -> intersect_cover to see if it is
                        % a splitting event
                        sev_areas = find(area_intersection >= intersect_cover);
                        if length(sev_areas)>1 % splitting event -> reccord the eddies generated
                            if isempty(CEs_traj(numtraj).Splitting_time)==1
                                CEs_traj(numtraj).Splitting_time(1) = indy+DT;
                                CEs_traj(numtraj).Splitted_in{1} = IND(matching_contour(sev_areas),indy+DT);
                                time_split = 1;
                            else
                                time_split = time_split + 1;
                                CEs_traj(numtraj).Splitting_time(end+1) = indy+DT;
                                CEs_traj(numtraj).Splitted_in{time_split} = IND(matching_contour(sev_areas),indy+DT);
                            end
                           split_id(IND(matching_contour(sev_areas),indy+DT),indy+DT) = numtraj_tot;
                        end

                        % Splitting or not, apply the cost function if more
                        % than 1 contour
                        [min_CF] = cori_cost_function(matching_contour,indy,indx,Radius,Amplitude,EKE,Xcenter,Ycenter,...
                            mean_delt_Rad,mean_delt_Ampl,mean_delt_EKE,mean_delt_dist,std_delt_Rad,std_delt_Ampl,std_delt_EKE,std_delt_dist,DT);
                        eddy_next = matching_contour(min_CF);
                    end
                end

                if isempty(eddy_next) == 0 % an eddy is found

                    % fill the trajectory
                    for dt=1:DT
                        CEs_traj(numtraj).Xcenter(end+1) = ((DT-dt)*Xcenter(indx,indy) + Xcenter(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).Ycenter(end+1) = ((DT-dt)*Ycenter(indx,indy) + Ycenter(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).Xcentroid(end+1) = ((DT-dt)*Xcentroid(indx,indy) + Xcentroid(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).Ycentroid(end+1) = ((DT-dt)*Ycentroid(indx,indy) + Ycentroid(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).Radius(end+1) = ((DT-dt)*Radius(indx,indy) + Radius(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).Area(end+1) = ((DT-dt)*Area(indx,indy) + Area(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).Amplitude(end+1) = 100*((DT-dt)*Amplitude(indx,indy) + Amplitude(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).EKE(end+1) = ((DT-dt)*EKE(indx,indy) + EKE(eddy_next,indy+DT)*dt)/DT;
                        CEs_traj(numtraj).Date(end+1) = date_num(indy+dt);
                        CEs_traj(numtraj).Time_index(end+1) = indy+dt;
                        CEs_traj(numtraj).Lifetime = CEs_traj(numtraj).Lifetime+1;
                        if strcmp(Extraction_Type,'Full Extraction') ==1
                            CEs_traj(numtraj).Speed(end+1) = ((DT-dt)*Speed(indx,indy) + Speed(eddy_next,indy+DT)*dt)/DT;
                            CEs_traj(numtraj).Vorticity(end+1) = ((DT-dt)*Vorticity(indx,indy) + Vorticity(eddy_next,indy+DT)*dt)/DT;
                            CEs_traj(numtraj).OW(end+1) = ((DT-dt)*OW(indx,indy) + OW(eddy_next,indy+DT)*dt)/DT;
                        end
                        if dt==DT
                            CEs_traj(numtraj).Xcontour{end+1} = CEs{eddy_next,indy+DT,1};
                            CEs_traj(numtraj).Ycontour{end+1} = CEs{eddy_next,indy+DT,2};
                            CEs_traj(numtraj).Eddy_index(end+1) = IND(eddy_next,indy+DT);
                            CEs_traj(numtraj).ID_eddies(end+1) = ID_cyclo(IND(eddy_next,indy+DT),indy+DT);
                            CEs_traj(numtraj).Eddy_found_at(end+1) = DT;
                        else
                            CEs_traj(numtraj).Xcontour{end+1} = NaN;
                            CEs_traj(numtraj).Ycontour{end+1} = NaN;
                            CEs_traj(numtraj).Eddy_index(end+1) = NaN;
                            CEs_traj(numtraj).ID_eddies(end+1) = NaN;
                            CEs_traj(numtraj).Eddy_found_at(end+1) = NaN;
                        end

                    end
                    if isnan(idtraj(IND(eddy_next,indy+DT),indy+DT)) == 0 % the matching eddy is already part of a trajectory -> merging event
                        CEs_traj(numtraj).Merged_with_traj(end+1) = idtraj(IND(eddy_next,indy+DT),indy+DT);
                        CEs_traj(numtraj).Merging_time(end+1) = indy+DT;
                        lifetime(numtraj) = CEs_traj(numtraj).Lifetime;
                        eddy = 0;
                        % -> the trajectory is stopped
                        break
                    end

                    idtraj(IND(eddy_next,indy+DT),indy+DT) = numtraj_tot;
                    % go to next map, looking for the next eddy
                    indy = indy+DT;
                    indx = eddy_next;
                    break
                end
            end

            if DT==nDT && isempty(eddy_next) ==1 	% at the end of the trajectory
                lifetime(numtraj) = CEs_traj(numtraj).Lifetime; % reccording the lifetime
                eddy = 0;
                break
            end
        end
    end
end

% Last saving
aa = aa+1;
if aa<10; aa_2=['0',num2str(aa)]; else aa_2=num2str(aa); end
save([output_dir, '/CE_Trajectories', aa_2, '.mat'],'Metadata','CEs_traj','idtraj','split_id','numtraj','lifetime','ID_cyclo') %Create new matrix
disp(['CEs ' aa_2 ' successfully saved'])

end






